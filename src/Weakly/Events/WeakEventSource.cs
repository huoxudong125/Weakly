using System;
using System.Collections.Generic;
using System.Reflection;

namespace Weakly
{
    /// <summary>
    /// A weak event source that does not hold any strong reference to the event listeners.
    /// </summary>
    /// <typeparam name="TEventArgs">The type of the event data generated by the event.</typeparam>
    public abstract class WeakEventSourceBase<TEventArgs>
    {
        private readonly List<Handler> _eventHandlerEntries = new List<Handler>();
        private readonly WeakReference _gcSentinel = new WeakReference(new object());

        private void CleanIfNeeded()
        {
            if (_gcSentinel.IsAlive)
                return;

            _gcSentinel.Target = new object();

            for (var i = _eventHandlerEntries.Count - 1; i >= 0; i--)
            {
                var entry = _eventHandlerEntries[i];
                if (!entry.IsAlive)
                    _eventHandlerEntries.RemoveAt(i);
            }
        }

        /// <summary>
        /// Adds the specified event handler.
        /// </summary>
        /// <param name="eventHandler">The event handler.</param>
        protected void Add(Delegate eventHandler)
        {
            if (eventHandler == null) return;
            if (eventHandler.Target == null)
                throw new ArgumentException("Cannot create weak event to static method.");
            if (eventHandler.GetMethodInfo().IsClosure())
                throw new ArgumentException("Cannot create weak event to anonymous method with closure.");

            lock (_eventHandlerEntries)
            {
                CleanIfNeeded();
                _eventHandlerEntries.Add(new Handler(eventHandler.Target, eventHandler.GetMethodInfo()));
            }
        }

        /// <summary>
        /// Removes the specified event handler.
        /// </summary>
        /// <param name="eventHandler">The event handler.</param>
        protected void Remove(Delegate eventHandler)
        {
            if (eventHandler == null) return;

            lock (_eventHandlerEntries)
            {
                CleanIfNeeded();

                for (var i = _eventHandlerEntries.Count - 1; i >= 0; i--)
                {
                    var entry = _eventHandlerEntries[i];
                    var target = entry.Target;

                    if (target == eventHandler.Target && entry.Method == eventHandler.GetMethodInfo())
                    {
                        _eventHandlerEntries.RemoveAt(i);
                        break;
                    }
                }
            }
        }

        /// <summary>
        /// Raises the event.
        /// </summary>
        /// <param name="sender">The source of the event.</param>
        /// <param name="e">An object that contains the event data.</param>
        public void Raise(object sender, TEventArgs e)
        {
            Handler[] invocationList;
            lock (_eventHandlerEntries)
            {
                CleanIfNeeded();
                invocationList = _eventHandlerEntries.ToArray();
            }

            OnRaise(sender, e);

            foreach (var entry in invocationList)
            {
                entry.Invoke(sender, e);
            }
        }

        /// <summary>
        /// Called when the event is raised.
        /// </summary>
        /// <param name="sender">The source of the event.</param>
        /// <param name="e">An object that contains the event data.</param>
        protected abstract void OnRaise(object sender, TEventArgs e);

        #region Private class

        private sealed class Handler
        {
            private readonly WeakReference _instance;
            private readonly MethodInfo _method;

            public Handler(object target, MethodInfo method)
            {
                _instance = new WeakReference(target);
                _method = method;
            }

            public bool IsAlive
            {
                get { return _instance.IsAlive; }
            }

            public object Target
            {
                get { return _instance.Target; }
            }

            public MethodInfo Method
            {
                get { return _method; }
            }

            public void Invoke(object sender, TEventArgs args)
            {
                var target = Target;
                if (target != null)
                    Builders.Builder.OpenAction.BuildAction<object, TEventArgs>(Method)(target, sender, args);
            }
        }

        #endregion
    }

    /// <summary>
    /// A weak event source that does not hold any strong reference to the event listeners.
    /// </summary>
    public sealed class WeakEventSource : WeakEventSourceBase<EventArgs>
    {
        private EventHandler _staticEventHandlers;

        /// <summary>
        /// Adds the specified event handler.
        /// </summary>
        /// <param name="eventHandler">The event handler.</param>
        public void Add(EventHandler eventHandler)
        {
            if (eventHandler == null) return;
            if (eventHandler.Target == null || eventHandler.Target is IWeakEventHandler)
            {
                _staticEventHandlers += eventHandler;
                return;
            }

            base.Add(eventHandler);
        }

        /// <summary>
        /// Removes the specified event handler.
        /// </summary>
        /// <param name="eventHandler">The event handler.</param>
        public void Remove(EventHandler eventHandler)
        {
            if (eventHandler == null) return;
            if (eventHandler.Target == null || eventHandler.Target is IWeakEventHandler)
            {
                _staticEventHandlers -= eventHandler;
                return;
            }

            base.Remove(eventHandler);
        }

        /// <summary>
        /// Notifies all static event handlers.
        /// </summary>
        /// <param name="sender">The source of the event.</param>
        /// <param name="e">An object that contains the event data.</param>
        protected override void OnRaise(object sender, EventArgs e)
        {
            var staticHandlers = _staticEventHandlers;
            if (staticHandlers != null)
            {
                staticHandlers(sender, e);
            }
        }
    }

    /// <summary>
    /// A weak event source that does not hold any strong reference to the event listeners.
    /// </summary>
    /// <typeparam name="TEventArgs">The type of the event data generated by the event.</typeparam>
    public sealed class WeakEventSource<TEventArgs> : WeakEventSourceBase<TEventArgs>
        where TEventArgs : EventArgs
    {
        private EventHandler<TEventArgs> _staticEventHandlers;

        /// <summary>
        /// Adds the specified event handler.
        /// </summary>
        /// <param name="eventHandler">The event handler.</param>
        public void Add(EventHandler<TEventArgs> eventHandler)
        {
            if (eventHandler == null) return;
            if (eventHandler.Target == null || eventHandler.Target is IWeakEventHandler)
            {
                _staticEventHandlers += eventHandler;
                return;
            }

            base.Add(eventHandler);
        }

        /// <summary>
        /// Removes the specified event handler.
        /// </summary>
        /// <param name="eventHandler">The event handler.</param>
        public void Remove(EventHandler<TEventArgs> eventHandler)
        {
            if (eventHandler == null) return;
            if (eventHandler.Target == null || eventHandler.Target is IWeakEventHandler)
            {
                _staticEventHandlers -= eventHandler;
                return;
            }

            base.Remove(eventHandler);
        }

        /// <summary>
        /// Notifies all static event handlers.
        /// </summary>
        /// <param name="sender">The source of the event.</param>
        /// <param name="e">An object that contains the event data.</param>
        protected override void OnRaise(object sender, TEventArgs e)
        {
            var staticHandlers = _staticEventHandlers;
            if (staticHandlers != null)
            {
                staticHandlers(sender, e);
            }
        }
    }
}
